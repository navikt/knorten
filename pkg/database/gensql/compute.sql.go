// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: compute.sql

package gensql

import (
	"context"
)

const computeInstanceCreate = `-- name: ComputeInstanceCreate :exec
INSERT INTO compute_instances (
    "team_id",
    "instance_name",
    "machine_type"
) VALUES (
    $1,
    $2,
    $3
)
`

type ComputeInstanceCreateParams struct {
	TeamID       string
	InstanceName string
	MachineType  ComputeMachineType
}

func (q *Queries) ComputeInstanceCreate(ctx context.Context, arg ComputeInstanceCreateParams) error {
	_, err := q.db.ExecContext(ctx, computeInstanceCreate, arg.TeamID, arg.InstanceName, arg.MachineType)
	return err
}

const computeInstanceDelete = `-- name: ComputeInstanceDelete :exec
DELETE
FROM compute_instances
WHERE team_id = $1
`

func (q *Queries) ComputeInstanceDelete(ctx context.Context, teamID string) error {
	_, err := q.db.ExecContext(ctx, computeInstanceDelete, teamID)
	return err
}

const computeInstanceGet = `-- name: ComputeInstanceGet :one
SELECT team_id, instance_name, machine_type
FROM compute_instances
WHERE team_id = $1
`

func (q *Queries) ComputeInstanceGet(ctx context.Context, teamID string) (ComputeInstance, error) {
	row := q.db.QueryRowContext(ctx, computeInstanceGet, teamID)
	var i ComputeInstance
	err := row.Scan(&i.TeamID, &i.InstanceName, &i.MachineType)
	return i, err
}

const supportedComputeMachineTypes = `-- name: SupportedComputeMachineTypes :many
SELECT unnest(enum_range(NULL::COMPUTE_MACHINE_TYPE))::text
`

func (q *Queries) SupportedComputeMachineTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, supportedComputeMachineTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var column_1 string
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
