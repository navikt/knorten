// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: events.sql

package gensql

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const eventCreate = `-- name: EventCreate :exec
INSERT INTO
    Events (op, resource_type, param, status, deadline)
VALUES
    (
        $1,
        $2,
        $3,
        'new',
        NOW() + INTERVAL $4
    )
`

type EventCreateParams struct {
	Op           Op
	ResourceType ResourceType
	Param        json.RawMessage
	Duration     time.Time
}

func (q *Queries) EventCreate(ctx context.Context, arg EventCreateParams) error {
	_, err := q.db.ExecContext(ctx, eventCreate,
		arg.Op,
		arg.ResourceType,
		arg.Param,
		arg.Duration,
	)
	return err
}

const eventGet = `-- name: EventGet :one
SELECT
    id,
    op,
    resource_type,
    param,
    status,
    deadline,
    created_at,
    updated_at
FROM
    Events
WHERE
    id = $1
`

func (q *Queries) EventGet(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.db.QueryRowContext(ctx, eventGet, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Op,
		&i.ResourceType,
		&i.Param,
		&i.Status,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const eventLogCreate = `-- name: EventLogCreate :exec
INSERT INTO
    Event_Logs (event_id, message)
VALUES
    ($1, $2)
`

type EventLogCreateParams struct {
	EventID uuid.UUID
	Message string
}

func (q *Queries) EventLogCreate(ctx context.Context, arg EventLogCreateParams) error {
	_, err := q.db.ExecContext(ctx, eventLogCreate, arg.EventID, arg.Message)
	return err
}

const eventLogsForEventGet = `-- name: EventLogsForEventGet :many
SELECT
    id,
    event_id,
    message,
    created_at
FROM
    Event_Logs
WHERE
    event_id = $1
ORDER BY
    created_at DESC
`

func (q *Queries) EventLogsForEventGet(ctx context.Context, eventID uuid.UUID) ([]EventLog, error) {
	rows, err := q.db.QueryContext(ctx, eventLogsForEventGet, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventLog{}
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventProlongDeadline = `-- name: EventProlongDeadline :exec
UPDATE
    Events
SET
    deadline = deadline + INTERVAL $1
WHERE
    id = $2
`

type EventProlongDeadlineParams struct {
	Duration time.Time
	ID       uuid.UUID
}

func (q *Queries) EventProlongDeadline(ctx context.Context, arg EventProlongDeadlineParams) error {
	_, err := q.db.ExecContext(ctx, eventProlongDeadline, arg.Duration, arg.ID)
	return err
}

const eventSetStatus = `-- name: EventSetStatus :exec
UPDATE
    Events
SET
    status = $1
WHERE
    id = $2
`

type EventSetStatusParams struct {
	Status EventStatus
	ID     uuid.UUID
}

func (q *Queries) EventSetStatus(ctx context.Context, arg EventSetStatusParams) error {
	_, err := q.db.ExecContext(ctx, eventSetStatus, arg.Status, arg.ID)
	return err
}

const eventsGetNew = `-- name: EventsGetNew :many
SELECT
    id, op, resource_type, param, status, deadline, created_at, updated_at
FROM
    Events
WHERE
    status = "new"
ORDER BY
    created_at DESC
`

func (q *Queries) EventsGetNew(ctx context.Context) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, eventsGetNew)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Op,
			&i.ResourceType,
			&i.Param,
			&i.Status,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventsGetOverdue = `-- name: EventsGetOverdue :many
SELECT
    id, op, resource_type, param, status, deadline, created_at, updated_at
FROM
    Events
WHERE
    status = "new"
    AND deadline < NOW()
`

func (q *Queries) EventsGetOverdue(ctx context.Context) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, eventsGetOverdue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Op,
			&i.ResourceType,
			&i.Param,
			&i.Status,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
